# 基础知识

ggplot2语法可以划分成以下几个部分：

-   数据集（data）：这部分包括了数据集的清洗整理，不再赘述。
-   图像属性（aes）
-   映射（mapping）：各种图像属性的空间映射。
-   几何对象（geom）：决定了图形的类型
-   标度（scale）：对数据信息进行重新汇总计算。
-   统计变换（stats）
-   位置变换（position）
-   坐标系（coord）
-   分面（facet）
-   主题（theme）：对图形精雕细琢。

## 图层

ggplot2通过添加图层的方法来绘制想要的结果，每一个图层需要组合相应的几何对象。图层之间用`+`连接。同时越往后，其图层越在上方。

## 绘图步骤（图层叠加策略）

1.  创建ggplot2对象

通过`ggplot()`函数创建，这是最底层的函数。该函数有两个主要参数，`data`和`mapping`，这两个参数将被设置为全局的默认参数。只有在新添加图层里重新显示声明，才会被改变。

ggplot2对象在加上图层前没有任何几何图形，只是空白的坐标轴面板。

2.  添加图层

使用`geom_xx()`函数添加几何对象图层，函数的参数定义了各种组件： -
mapping：映射。 - data：重新声明数据集 -
`...`：几何对象中特有的其他参数，包括一些美学属性或其他设置。 -
stat：统计变换。 - position：位置调整。

3.  调整标度

每个图形属性的映射（例如颜色，大小等）都对应一个标度。

4.  指定坐标系统

默认是笛卡尔坐标系，可以更换坐标轴。同时也可以对某一个坐标轴的细节进行修改。

5.  设定分面系统。

将某个变量进行分面变换，包括按行、列和网格等形式分面绘图.

6.  调整图例

通过`guides()`函数调整图例，主要包括连续型和离散型两种类型的图例。

7.  设定主题

上述并非固定步骤，还需结合实际情况调整。

## 图形属性（美学属性）

每一个图形属性都可以映射为一个变量（离散变量或连续变量）或者单独设定成一个常数。图形属性不进行显式声明则使用默认值。

美学属性单独赋值和映射的区别（以颜色为例：）

```{r}
#| vscode: {languageId: r}
library(tidyverse)
library(patchwork)
p1 <- mpg %>% ggplot(aes(displ, hwy)) + geom_point(size = 3, aes(colour="red"))  
p2 <- mpg %>% ggplot(aes(displ, hwy)) + geom_point(size = 3, colour="red") 
p1 + p2
```

### 常用图形属性类型

不同的几何对象有不同的图形属性，常见的有： 
1. color（colour）：线条颜色
2. size 
3. shape  
4. fill：填充颜色
5. group：分组
6. x，y：坐标位置

### 分组

在ggplot2里，几何对象可以大致分为个体几何对象和群组几何对象两类。个体几何对象针对数据集中的每个单独的数据点或观测值绘制一个图形元素。每个图形元素独立表示一个数据点，使得观察者可以直接看到数据集中每个观测值的特征。例如，在散点图中，每个点就是一个个体几何对象，代表数据集中的一个观测。群组几何对象与个体几何对象不同，群组几何对象代表的是数据集中多个观测值的集合或总体。这种对象通常用于展示分组或分类数据的特征，或者是某种统计摘要（如平均值、中位数等）。例如一些多边形：在条形图中，每个条形可能代表一组数据的平均值或总和，而在折线图中，线条可能表示随时间变化的数据趋势。

线条和路径这种几何对象介于这两者之间：每条线都由许多线段组成，而每条线段又代表两个点。

`group`分组图形属性用于指定数据点的分组方式，用来控制哪些观测值用哪些图形元素。默认情况下，图中**所有离散型变量**的交互作用被设为分组的默认值，通常这样已经可以正确地给数据分组，但是如果没能正确分组或者图中没有离散型变量，那么就需要自定义分组结构，即将`group`映射到一个在不同的组有不同取值的变量。当现有的单个变量不能正确地分组，而两个变量地组合可以正确分组时，可以使用`interaction()`函数。以下三种情况需要改变默认分组：

#### 多个分组与单个图形属性

很多时候，我们都想将数据分成若干组，并用相同的方式对每个组进行渲染。当从总体上来查看数据时，我们通常希望区分每个个体（在视觉上能够辨认出不同的个体）而不是识别它们（识别通常需要标签或图例来帮助用户读取具体的个体名字或类别），这在含有多个个体的纵向数据中是很常见的。常见的就是spaghetti
plot的绘制：

```{r}
#| vscode: {languageId: r}
library(tidyverse)
library(nlme)
ggplot(Oxboys, aes(age, height, group = Subject)) + 
  geom_line(linewidth = 1) +
  theme_minimal()
```

#### 不同图层上的不同分组

通过将分组属性映射到不同的输入变量是常见的做法，同时利用`group = 1`的映射可以将分组转换为默认分组：

```{r}
library(tidyverse)
library(nlme)
ggplot(Oxboys, aes(age, height, group = Subject)) + 
  geom_line(linewidth = 1) +
  geom_smooth(aes(group = 1), method = "lm", lwd = 2, color = "red", se = FALSE) +
  theme_minimal()
```

#### 修改默认分组

由于图像中的离散型变量会进行默认分组，所以在后续图层的绘制时，有必要进行分组的修改：

```{r}
ggplot(Oxboys, aes(Occasion, height)) +
  geom_boxplot() +
  geom_line(aes(group = Subject), color = "red") +
  theme_minimal()
```

#### 匹配图形属性和图形对象

群体几何对象的图形映射要映射给整体。同时，线条和路径遵循差一原则：观测点比线段数目多一，第一条线段将使用第一条观测的图形属性，第二条线段将使用第二条观测的图形属性，依次类推，这意味着最后一条观测的图形属性不会被用到。这样的图形属性一般就只会映射颜色，宽度，而线条类型则必须是一个整数，R不能绘制不同线条类型相连接的线条：

```{r}
library(tidyverse)
library(patchwork)
df <- tibble(
  x = 1:3,
  y = 1:3
)

p1 <- ggplot(df, aes(x, y, color = x)) +
  geom_point(size = 5) +
  geom_line(lwd = 2) +
  theme_minimal()
# 连续型颜色的映射会对颜色梯度进行线性插值

p2 <- df %>% mutate(x = factor(x)) %>%
ggplot(aes(x, y, color = x)) +
  geom_point(size = 5) +
  geom_line(group = 1, lwd = 2) +
  theme_minimal()

p1 + p2
```

## 几何对象

几何对象执行图层的渲染，控制生成图像的类型。

### 几何对象类型

几何对象可以包括以下几种：

![](note_img/几何对象类型.png)

### 几何对象图形属性值和统计变换

每个几何对象都有一组他能识别的图形属性和一组绘图所需要的值（例如，一个点含有颜色、大小和形状等图形属性，以及x和y位置坐标；一个条形含有高度、条宽、边界颜色和填充颜色等颜色属性值）。有些几何对象的图形属性略有不同，例如tile瓦片图形需要指定上下左右位置（ymin、ymax、xmin、xmax）。

同时，每一个几何对象都有一个默认的统计变换，对应地，每一个统计变换也都有一个默认的几何对象。例如封箱（bin）统计变换默认使用条形几何对象（bar）。修改这些默认值虽然能生成符合语法地绘图，但是它们可能会违法一些绘图惯例。

![](note_img/几何对象详解.png)

### 简单介绍

#### geom_polygon()

绘制多边形，即**填充后的路径（path）**。数据框中的每一行代表了多边形的一个顶点，如下所示：

```{r}
demo <- tibble(
  x = c(1, 2, 2, 1, 3, 4, 4, 3),
  y = c(1, 1, 2, 2, 1, 1, 2, 2),
  group = rep(c("a", "b"), each = 4)
)

ggplot(demo, aes(x = x, y = y)) +
  geom_polygon(fill = "white", color = "black") +
  theme_minimal()
# 没有指定分组，图形的首尾两点进行了闭合连接
```

通过多边形可以实现各种有想象创造力的图形，例如我们可以通过该函数绘制分组的柱状图：

```{r}
demo <- tibble(
  x = c(1, 2, 2, 1, 3, 4, 4, 3),
  y = c(1, 1, 2, 2, 1, 1, 2, 2),
  group = rep(c("a", "b"), each = 4)
)

ggplot(demo, aes(x = x, y = y, group = group)) +
  geom_polygon(fill = "white", color = "black") +
  theme_minimal()
```

## 统计变换

对数据进行统计变换，即通常以某种方式对数据信息进行汇总。例如，平滑（smoother）是一个很有用的统计变换，它能在一些限制条件的约束下给定x值时y的平均值。

统计（stat）变换函数在数据被绘制出来之前对数据进行聚合和其他计算。它将输入的数据集看做输入，将返回的数据集作为输出，因此此统计变换可以向原数据集中插入新的变量，通过查看统计变换的帮助文档找到计算的变量名。例如，常被用来绘制直方图的`bin`统计变换会生成如下常见变量（`?ggplot2::stat_bin()`）：count---每个组里观测值的数目；density---个组里观测值的密度（占整体的百分数、组宽）。这些生成的变量可以被直接调用，通过`after_stat()`函数指定即可：

```{r}

# geom_histogram(
#   mapping = NULL,
#   data = NULL,
#   stat = "bin",
#   position = "stack",
#   ...,
#   binwidth = NULL,
#   bins = NULL,
#   na.rm = FALSE,
#   orientation = NA,
#   show.legend = NA,
#   inherit.aes = TRUE
# )

library(tidyverse)
mpg %>% 
  ggplot(aes(x = cty)) +
  geom_histogram(aes(y = after_stat(density)), fill = "steelblue") +    # 默认为 count
  theme_minimal()
```

如果不想使用统计变换，设置参数`stat = "identity"`即可。不使用统计变换（identity）的意思是，绘制的图形所需数据完全来自输入（y，ymin，ymax），或者来自统计摘要`stat_summary()`。

常见的统计变换函数如下图： 

![](note_img/统计变换.png)

### 深入统计变换

之前我们都是使用`geom_xx()`添加图层，同时使用函数里面的`stat`参数进行统计变换。其实我们也可以直接使用`stat_xx()`函数进行图层的创建，同时使用其中的`geom`参数创建几何对象（这些几何对象一定是没有统计变换的基本对象）。前者更侧重图表类型的绘制，通过修改统计变换参数实现绘图前数据的统计变换；后者更侧重统计变换过程，所以可以直接根据统计变换结果绘制不同的图表。但需要注意的是，统计变换的结果一定要与将要绘制的几何对象图形属性相匹配。

具体来说，其实无论是什么样的几何对象，基本上都使用条线点组合而成。以箱线图的绘制为例，geom_boxplot()
是一个统一的函数，封装了计算和绘制的步骤，使用户能够更方便地绘制盒须图。stat_boxplot()
负责计算出盒须图需要的五个数值：最小值、第一四分位数、中位数、第三四分位数和最大值。这些计算出的数值随后被
geom_boxplot()
所调用，以绘制出标准的盒须图，包括盒子、须线以及可能的异常值。

#### 统计摘要（stat_summary()）

对于每个x的取值，计算**对应y的统计摘要**通常是有用的。`stat_summary()`使用ymin，y和ymax等图形属性，为**汇总y的条件分布**提供了一种灵活的方式。该统计摘要默认几何对象为`pointrange`，即：用一条中间带点的竖直线代表一个区间。

函数及其参数如下：

```{r}
# stat_summary(
#   mapping = NULL,
#   data = NULL,
#   geom = "pointrange",
#   position = "identity",
#   ...,
#   fun.data = NULL,
#   fun = NULL,
#   fun.max = NULL,
#   fun.min = NULL,
#   fun.args = list(),
#   na.rm = FALSE,
#   orientation = NA,
#   show.legend = NA,
#   inherit.aes = TRUE,
#   fun.y = deprecated(),
#   fun.ymin = deprecated(),
#   fun.ymax = deprecated()
# )
```

```{r}
library(tidyverse)
ggplot(mtcars, aes(cyl, mpg)) +
  stat_summary(fun = mean, fun.min = min, fun.max = max, geom = "pointrange") +
  # pointrange几何对象显然需要中间点以及竖线范围的两个极点的数值
  theme_minimal()
```

##### 单独的摘要计算函数

`fun`、`fun.min`、`fun.max`参数能够接受简单的数值型摘要计算函数，即该函数能够传入一个数值向量（x）并返回一个数值型结果（根据x分组的的统计摘要值），如mean()、median()、min()、max()函数等。其中`fun`参数更广泛，`fun.min`和`fun.max`则更关注最值的统计，一般与`geom = "errorbar"`配合使用。

```{r}
library(tidyverse)
ggplot(mtcars, aes(cyl, mpg)) +
  geom_point() +
  stat_summary(mapping = aes(color = "mean"), fun = mean , size = 4, geom = "point") +
  stat_summary(mapping = aes(color = "median"), fun = median, size = 4, geom = "point") +
  scale_color_manual(values = c("mean" = "red", "median" = "blue")) +
  theme_minimal()
```

```{r}
library(tidyverse)
ggplot(mtcars, aes(cyl, mpg)) +
  geom_point() +
  stat_summary(fun.min = min, fun.max = max, geom = "errorbar") +
  theme_minimal()
```

##### 统一的摘要计算函数

`fun.data`参数可以支持更复杂的摘要计算函数，它可以是来自`Hmisc`包中的函数，也可以是自己编写的摘要计算函数。此函数对于每个`x`值进行统计摘要的分组计算，且应返回一个包含至少三个变量的数据框：`ymin`、`y`和 `ymax`。

对于自编函数：

```{r}
library(tidyverse)
iqr <- function(x, ...) {
  qs <- quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
  names(qs) <- c("ymin", "ymax")
  return(qs)
}
ggplot(mtcars, aes(cyl, mpg)) +
  stat_summary(fun.data = iqr, fill = "#007c7c", geom = "ribbon", alpha = .7) +
  theme_minimal()
```

对于Hmisc包里面的函数调用，可以参考下图：

![](note_img/Hmisc.png)

```{r}
library(tidyverse)
ggplot(mtcars, aes(cyl, mpg)) +
  stat_summary(fun.data = mean_cl_boot, color = "#007c7c", geom = "errorbar") +
  theme_minimal()
```

#### 封箱统计变换函数（stat_bin()）

封箱统计函数的默认几何对象为`bar`，其参数如下：

```{r}

# stat_bin(
#   mapping = NULL,
#   data = NULL,
#   geom = "bar",
#   position = "stack",
#   ...,
#   binwidth = NULL,
#   bins = NULL,
#   center = NULL,
#   boundary = NULL,
#   breaks = NULL,
#   closed = c("right", "left"),
#   pad = FALSE,
#   na.rm = FALSE,
#   orientation = NA,
#   show.legend = NA,
#   inherit.aes = TRUE
# )

```

#### 其余统计变换函数与自建统计变换函数

#### 结合几何对象和统计变换

将几何对象和不同的统计变换进行组合，可以轻松地绘制出新颖的图形，这在之前的代码中已经有所体现（一个几何对象对应一个统计变换）。类似地，ggplot2中有大量的几何对象就是基于其他几何对象衍生出来的（通过修改某个已存在的几何对象地默认图形属性或统计变换）：

![](note_img/combined-goems.png)

#### 结合统计变换与标度变换

虽然统计变换和标度变换是独立的两个步骤，但标度变换要先于统计变换，因此统计量都是基于标度变换后的数据进行计算的。例如：

```{r}
library(tidyverse)
library(patchwork)
p1 <- ggplot(diamonds, aes(x = carat)) +
  scale_x_continuous(limits = c(0, 3)) +
  stat_bin(aes(y = after_stat(density)), binwidth = .1, geom = "point") +
  theme_minimal()

p2 <- ggplot(diamonds, aes(x = carat)) +
  stat_bin(aes(y = after_stat(density)), binwidth = .1, geom = "point", color = "red") +
  scale_x_continuous(limits = c(0, 3)) +
  theme_minimal()

p1 / p2
# 统计变换永远基于标度变换，无论图层添加的顺序如何
```

## 位置调整

位置调整即是对该图层的元素位置进行微调。一般用于处理离散型数据，这主要是因为连续型数据很少出现完全重叠的问题，当出现了这类问题时（由于数据密度高），即使微调，如随机扰动，通常也无法解决问题。同时该方法对条形图和其他有组距的几何对象非常有用。位置调整有以下五种，既可以指定代表它们名称的字符串，也可以直接调用对应的位置调整函数：

![](note_img/position.png)

### 并排（dodge）

声明`position="dodge2"/position_dodge2()`，其中关于`position_dodge2()`函数：

```{r}

# position_dodge2(
#   width = NULL,
#   preserve = "total",
#   padding = 0.1,
#   reverse = FALSE
# )

```

### 堆叠（stack）

## 标度

标度（scale）控制着数据到图形属性的映射。标度将我们的数据转换为视觉上可以感知的东西：例如大小，颜色，位置或形状。标度也为我们提供了读图时所使用的工具：坐标轴和图例。这些被称作引导元素（guide），对于位置型图形属性，引导元素是坐标轴；而对于所有其他图形属性来说，引导元素是图例。

图形上所用的每一个图形属性都需要一个标度，也都对应着一个标度，每个标度都作用于图形中的所有数据。更准确地说，每一种标度都是从数据空间的某个区域（标度的定义域）到图形属性空间的某个区域（标度的值域）的一个函数。每种标度的定义域都对应着提供给这个标度的变量的取值范围，它可以是连续型、离散型（有序或无序）。而标度的值域则包含了我们可以感知的，R能够理解的、实实在在的图形属性：位置、颜色、形状、大小和线条类型。

### 标度的工作原理

标度的工作原理，其实就是标度的定义域和值域之间进行映射的过程。标度的定义域可能是连续型（实值区间），也可能是离散型（某些值组成的集合），同时值域也可以是连续型（穿过某种更复杂空间的一条一维路径）或离散型（输入值对应的图形属性值组成的一个向量）的。

没有标度就没有将数据转换为图形属性的途径，所以图形中使用的每一个图形属性都需要一个标度。执行标度的过程有三步：

#### 变换(transformation)

变换**仅针对连续型的定义域**。例如对数据取对数或者开根号。在变换完成后，将会基于变换后的数据计算每一层的**统计摘要**，然后再进行展示。

#### 训练(training)

在这个关键的阶段，将通过学习（learing）得到标度的定义域。有时，学习某个标度的定义相当简单直接：在一个仅有一个图层且仅呈现原始数据的图形中，这个学习过程包括确定某个（变换后的）连续型变量的最小值和最大值，或者是列出某个类别型变量的所有水平。但是，标度大多定义域往往必须在多个面板（panel）中反映出横跨多个数据集的多个图层。

#### 映射(mapping)

在知道标度的定义域和值域后，将执行这个映射数据到图形属性的函数。同时标度也支持缺失值的映射，通过`na.value`参数，我们也可以将缺失值映射到特定的图形属性。

### 标度的用法

每一种图形属性都拥有一个默认的标度，此标度将**在我们每次使用这个图形属性时被自动添加到图形中**。标度的种类依赖于变量的类型：分为连续型（变量为数值时）或离散型（变量为因子、逻辑值、字符时）。
在初始化整个图形和增加新图层时、默认的标度将自动增加。这意味着如果我们在之后修改了底层数据或图形属性映射，变量类型和标度类型之间可能出现不匹配的情况。当这种情况发生时，我们需要自行添加正确的标度。不过新版本的ggplot2可以自动完成变换。不过了解一下底层原理总是好的。

![](note_img/scale_type.png)

如果要添加一个不同的标度或修改默认标度的某些特征，我们必须构造一个新的标度，然后使用`+`将其添加到图形上。通过通用命名方案：`scale_`开头，加上图形属性名称（color，size等），最后以标度名称结尾（discrete，continuous等）。

### 标度的通用参数

以下参数对所有标度通用：

1.  `name`：设置坐标轴或图例上出现的标签。该参数可以直接通过`labs()`简写函数。

```{r}

# labs(
#   ...,
#   title = waiver(),
#   subtitle = waiver(),
#   caption = waiver(),
#   tag = waiver(),
#   alt = waiver(),
#   alt_insight = waiver()
# )  

# title:标题标签
# subtitle:子标题标签
# tag：标签默认在图的左上角
# caption：标签默认在图的右下角

```

2.  `limits`：固定标度的定义域。连续型标度接受一个**长度为2的数值型向量**；离散型标度接受一个**字符型向量**。一旦接受了limits，数据将不再进行任何训练，即任何不在此limits规定的定义域内的值均将被丢弃。这个丢弃过程是在统计量计算之前的，这点值得注意。

3.  `breaks`和`labels`：breaks控制着**显示在坐标轴或图例上的值**，即坐标轴上应该显示哪些刻度线的值，或连续型标度在一个图例中将被如何分段。而labels则指定了断点处显示的标签。设置了labels就必须指定breaks，只有这样才能保证这两个参数的正确匹配。当然也可以只设置breaks而不设置labels。

### 位置标度

每幅图形一定拥有两个位置标度，一个指定水平位置（x标度），另外一个指定竖直位置（y标度）。由于经常需要微调数据的定义域范围．所以也会使用辅助函数`xlim()`,`ylim()`。值得注意的是，默认情况下，位置标度的`limits`会对变量的定义域进行一定程度的扩展，这样就保证了数据与坐标轴不会发生重叠。使用`expand = expansion(mult = 0, add = 0)`来控制溢出量，第一个参数给出的是乘式的溢出量，第二个参数给出的是加式的溢出量。

#### 连续型

最常用的连续型位置标度是`scale_x_continuous()`和`scale_y_continuous()`。它们都将数据映射到x轴和y轴，而最有趣的变式是通过变换来形成的。每个连续型标度均可接受一个`trans`参数，允许指定若干种线性或非线性的变换。而每一种变换都是由所谓的"变换器"（transformer）来实现的，变换器描述了变换本身和对应的逆变换，以及如何去绘制标签。

![](note_img/标度转换器.png)

变换通常被用来修改位置标度，所以对于x，y和z标度都是有简便写法的：`scale_x_log1O()`和`scale_x_continuous(trans= "logl0")`是等价的。参数trans对任意的连续型标度均有效，包括后面的颜色梯度，但简便写法仅针对位置标度存在。

自行实施变换，比如直接绘制log10(x)和利用标度变换`scale_x_log()`是不同的，虽然两者在绘图区域生成完全相同的结果，但坐标轴和刻度标签却是不同的：

```{r}
#| vscode: {languageId: r}
library(tidyverse)
library(patchwork)
data(diamonds)

p1 <- ggplot(diamonds, aes(log10(carat), log10(price))) +
  geom_point() +
  theme_minimal()

p2 <- ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  theme_minimal()

p1 / p2
```

#### 日期和时间型

我们常常在绘制时间序列图时，用到日期和时间。日期和时间值基本上属于连续型，但在标注坐标轴时有特殊的处理方式。如果日期和时间值是其他格式的，则需使用`as.Date()`、`as.POSIXct()`或其他对其进行转换为`date`、`time`或`dttm`类型。

对于日期坐标轴，此标度`scale_x_date()`，`scale_y_date()`本身已经可以很好地选择默认值了，不过也可以进行微调：

- `date_breaks/date_minor_breaks`：指定日期间隔 
- `date_labels`：日期标签格式

还有一些常见的位置标度参数，不再赘述。

#### 离散型

离散型位置标度`scale_x_discrete()`，`scale_y_discrete()`将输入中的各水平映射为整数。**结果的顺序可用参数`breaks`进行控制，不想要的水平可以使用`limits`（或使用`xlim()`或`ylim()`）进行丢弃。**

### 颜色标度

除了位置标度以外，最常用的图形属性可能就是颜色了。基本的颜色标度对连续型值有三种基于渐变的方法，对离散型值由两种方法。

#### 连续型

```{r}

# scale_colour/fill_gradient(
#   ...,
#   low = "#132B43",
#   high = "#56B1F7",
#   space = "Lab",
#   na.value = "grey50",
#   guide = "colourbar",
#   aesthetics = "colour"
# )

# 双色梯度。顺序为从低到高。参数low和high用以控制此梯度两端的颜色。

# scale_colour/fill_gradient2(
#   ...,
#   low = muted("red"),
#   mid = "white",
#   high = muted("blue"),
#   midpoint = 0,
#   space = "Lab",
#   na.value = "grey50",
#   guide = "colourbar",
#   aesthetics = "colour"
# )

# 三色梯度。顺序为低一中一高。参数low和high作用同上，这两种标度还有一个中间色mid。中点midpoint的默认值为0，指定将输入数据中的具体值映射到中间色mid上。

# scale_colour/fill_gradientn(
#   ...,
#   colours,
#   values = NULL,
#   space = "Lab",
#   na.value = "grey50",
#   guide = "colourbar",
#   aesthetics = "colour",
#   colors
# )

```

```{r}
ggplot(mtcars, aes(mpg, disp)) +
  geom_point(aes(color = disp), size = 3) +
  scale_color_gradient2(mid = "white", midpoint = mean(mtcars$disp)) +
  theme_minimal()
```

关于`scale_color_gradientn()`，这是自定义的n色梯度。此标度需要赋给参数`colours`一个颜色向量，用来指定渐变颜色。不加其他参数的话，这些颜色在渐变中的位置均匀分布。如果需要让这些颜色在渐变中的位置不均匀分布，则可以使用参数`values`，该参数向量会为颜色向量中的每种颜色提供一个介于0和1之间的相对位置，例如：

```{r}
set.seed(123)
data <- data.frame(
  Temperature = seq(-10, 30, by = 0.5),
  Measurement = rnorm(81, mean = 10, sd = 5)
)
ggplot(data, aes(x = Temperature, y = Measurement)) +
  geom_point(aes(color = Temperature), size = 3) +
  scale_colour_gradientn(
    colors = c("blue", "white", "orange", "red"),
#     values = scales::rescale(c(-10, 0, 20, 30))
  ) +
  theme_minimal()
```

对温度分配颜色渐变，由于我们没有规定每个颜色的相对分布位置，所以ggplot2会默认均匀分布。此时0度并不是白色，但当我们需要强调0度为白色时，values参数则可以很好的体现这一点：使用`scales::rescale()`将所有标识温度标准化至0，1区间，这样就可以体现它们的相对位置：

```{r}
set.seed(123)
data <- data.frame(
  Temperature = seq(-10, 30, by = 0.5),
  Measurement = rnorm(81, mean = 10, sd = 5)
)
ggplot(data, aes(x = Temperature, y = Measurement)) +
  geom_point(aes(color = Temperature), size = 3) +
  scale_colour_gradientn(
    colors = c("blue", "white", "orange", "red"),
    values = scales::rescale(c(-10, 0, 20, 30))
  ) +
  theme_minimal()
```

#### 离散型

离散型数据有两种颜色标度。一种可以自动选择颜色，另一种可以轻松地从手工甄选的颜色集中选择颜色。

默认的配色方案，即`scale_colour/fill_hue()`，可通过沿若**hcl色轮**选取均匀分布的色相来生成颜色。这种方案对多至约8种颜色时都能有较好的效果。但对于更多的颜色，要区分开不同的颜色就变得比较困难了。默认配色的另外一个缺点是，由于所有颜色都拥有相同的明度和彩度，所以当我们进行黑白打印时，它们就会成为几近相同的灰影。

```{r}

# scale_colour_hue(
#   ...,
#   h = c(0, 360) + 15,
#   c = 100,
#   l = 65,
#   h.start = 0,
#   direction = 1,
#   na.value = "grey50",
#   aesthetics = "colour"
# )

```

除了这种基于计算的方案以外，另一种可选的方案是使用`ColorBrewer`配色，即使用`scale_color/fill_brewer()`这些手工甄选的颜色可在很多情境下良好地运作。

该函数支持多个调色板，可以查看帮助文档。对于类别型数据中的点而言，常用的调色板是"Set1"和"Dack2"，对面积而言则是"Set2"、"Pastel1"、"Pastel2"和"Accent"。

```{r}

# scale_colour_brewer(
#   ...,
#   type = "seq",
#   palette = 1,
#   direction = 1,
#   aesthetics = "colour"
# )

```

### 手动离散型标度

离散型标度`scale_linetype()`，`scale_size_discrete()`和`scale_shape()`基本上没有选项。这些标度仅仅是按一定的顺序将因子的水平映射到一系列取值中。

使用`scale_colour/shape/linetype_manual()`这些手动型标度创建新的标度。手动型标度拥有一个重要参数`values`。可以使用它来指定这个标度应该生成的值。如果这个**向量中的元素是有名称的**，则它将自动匹配输入和输出的值，否则它将按照离散型变量中水平的先后次序进行匹配。

```{r}
library(tidyverse)
ggplot(msleep, aes(x = brainwt, y = bodywt)) +
  geom_point(aes(color = vore), size = 3) +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(
    values = c(carni = 'red', insecti = 'yellow', herbi = 'green', omni = 'blue')) +
  theme_minimal()
```

## 分面

分面可以起到切割数据，生成一系列小联号图的作用，每个小图表示不同的数据子集。ggplot2包含两个分面类型：网格型（facet_grid）和封装型（facet_wrap）。使用`facet_grid()`进行二维分面，生成一个2维的面板网络，面板的行和列通过变量来定义；使用`facet_wrap()`进行一维分面，即先生成一个1维的面板条块，然后再封装到2维中。

![](note_img/分面类型.png)

### 网格封面

```{r}

# facet_grid(
#   rows = NULL,
#   cols = NULL,
#   scales = "fixed",
#   space = "fixed",
#   shrink = TRUE,
#   labeller = "label_value",
#   as.table = TRUE,
#   switch = NULL,
#   drop = TRUE,
#   margins = FALSE,
#   facets = deprecated()
# )

```

其主要参数：

-   `rows, cols`:
    由`vars()`引用的变量或表达式的集合（vars()里面可以指定单个或多个列），用于定义多面板图的行和列维度的分组。这些变量可以是命名的（名称将传递给labeller函数）。除了使用rows和cols进行指定外，也可以使用公式创建分面，其中行本身位于公式的左侧
    (LHS)，列位于右侧 (RHS)。
    如果在该维度（无论是行还是列）上不应用分面，那么可以在公式中使用点来表示该维度。
-   `scales`:
    所有面板中是否共享刻度的设置。默认值为`fixed`，表示刻度在所有面板中保持一致；`free_x`表示刻度在行（水平）方向上可以变化；`free_y`表示刻度在列（垂直）方向上可以变化；`free`表示刻度在行和列方向上都可以变化。
-   `space`:
    一般会和`scales`参数一起使用，默认为`fixed`，如果设置为`free`，每列（行）的宽度（高度）与该列（行）的标度范围成比例。这将使得所有面板的标度比例相同：每个面板中的1cm都映射为相同的数据范围，例如面板a有2个单位的范围，面板b有4个单位的范围，那么三分之一的空间将分配给a，其余的分配给b。也可以设置`free_x`，`free_y`。
-   `switch`:
    默认情况下，标签显示在图的上方和右侧。如果设置为`x`，则顶部标签将显示在底部。如果设置为`y`，则右侧标签将显示在左侧。也可以设置为`both`，即两侧的标签都进行调整。
-   `drop`:
    如果为TRUE（默认值），将自动删除数据中未使用的因子水平。如果为FALSE，则显示所有因子水平，无论其是否在数据中出现。
-   `margins`:
    一个逻辑值或字符向量。如果为TRUE，将为所有分面变量绘制汇总边际，形成列联表形式的边际图（边际图的分组方式与其他面板中的分组方式相同）。也可以传入变量名的字符串。

此外，还有一个参数`labeller`用于修改分面标签的样式。该参数接受函数`labeller()`来进行标签的细节修改。`labeller()`函数使得为不同的因子变量分配不同的标签文字变得容易。标签函数本身可以是一个函数，也可以接受一个**命名**的字符串向量。

```{r}
#| vscode: {languageId: r}
library(tidyverse)
library(showtext)
library(ggtext)
font_path <- "fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)
showtext_auto()
axis1 <- "<strong>axis x </strong>: hwy<br>"
axis2 <- "<strong>axis y </strong>: cty"
subtitle <- str_c(axis1, axis2)
facet_x <- c("Audi", "Chevrolet", "Dodge")
names(facet_x) <- c("audi", "chevrolet", "dodge")
# 为向量命名

slice_head(mpg, n = 50) %>%
  ggplot(aes(x = hwy, y = cty)) + 
  geom_point(size = 2, color = "#FC4E07") +
  facet_grid(
    cols = vars(manufacturer),
    rows = vars(drv),
    scales = "free_y",
    switch = "both",
    space = "free", 
    labeller = labeller(.rows = label_both, .cols = facet_x)
  ) +
  labs(title = "ABOUT FACET", subtitle = subtitle) +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25, color = "#FC4E07"), 
    plot.subtitle = element_markdown(family = "serif", hjust = 0.01, size = 12),
    panel.border = element_rect(color = "grey60", fill = NA),
    axis.title = element_blank(),
    strip.placement = "outside",
    strip.background = element_rect(fill = "#FC4E07"),
    strip.text = element_text(color = "white", size = 12),
    strip.switch.pad.grid = unit(0.3, "cm")
  )

# ggsave(filename = "plot/notes/output_img/facet_plot.png", dpi = 90)
```

![](output_img/facet_plot.png)

### 封装分面

`facet_wrap()`并不是用两个或者更多的变量来生成一个2维网络，而是先生成以一个长的面板条块（由任意数目的变量生成），然后把它封装在2维中。与facet_grid()相比，这通常更好地利用了屏幕空间，因为大多数显示器的形状是近似矩形的，也更容易展示单变量的分面。

```{r}

# facet_wrap(
#   facets,
#   nrow = NULL,
#   ncol = NULL,
#   scales = "fixed",
#   shrink = TRUE,
#   labeller = "label_value",
#   as.table = TRUE,
#   switch = deprecated(),
#   drop = TRUE,
#   dir = "h",
#   strip.position = "top"
# )

```

主要参数说明：

-   `facets`:
    用于定义分面组的变量或表达式，通过`vars()`引用。但分面超过两个变量时，要么声明为向量形式`c("a", "b")`，要么通过公式：`~a + b`。
-   `nrow、ncol`: 分面的行数和列数。
-   `strip.position`:
    默认情况下，标签显示在图的顶部。可以通过设置`strip.position = c("top", "bottom", "left", "right")`来将标签放置在四个边的任意一个位置。
-   `dir`: 分面的方向，可以是`h`表示水平（默认值），或`v`表示垂直。

```{r}
#| vscode: {languageId: r}
library(tidyverse)
library(showtext)
library(ggtext)
font_path <- "fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)
showtext_auto()

ggplot(economics_long, aes(date, value)) +
  geom_line() +
  facet_wrap(
    facets = vars(variable), 
    scales = "free", 
    ncol = 2, 
    strip.position = "right"
    ) +
  labs(title = "ABOUT FACET") +
  theme_minimal()+
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25, color = "#FC4E07"), 
    axis.title = element_blank(),
    strip.placement = "outside",
    strip.background = element_rect(fill = "#FC4E07"),
    strip.text = element_text(color = "white", size = 12),
    strip.switch.pad.grid = unit(0.3, "cm")
  )
```

## 坐标系

坐标系是将两种位置标度结合在一起的2维定位系统。大部分的图形都默认为笛卡尔坐标系，即常见的x和y组成的2维坐标系，命名为`coord_cartesian()`。其实将x和y称作位置1和位置2可能会更合适，因为图形位置属性的名字会随着坐标系的不同而不同，比如极坐标系中将其称作角度和半径，而地图中则被称作维度和经度。

### 笛卡尔坐标系

有四种基于笛卡尔的坐标系：`coord_cartesian()`，`coord_equal()`，`coord_flip()`和`coord_trans()`，其中x和y的位置都是正交映射到图形的位置上。

```{r}

# coord_cartesian(
#   xlim = NULL,
#   ylim = NULL,
#   expand = TRUE,
#   default = FALSE,
#   clip = "on"
# )

```

-   `xlim、ylim`：x轴和y轴的限制范围。与在标度中设置限制范围不一样（任何超出此范围的数据都会被删除），该参数只会展示一小片的图形区域，像放大镜一样相对放大或缩小坐标系。
-   `expand`：如果为TRUE（默认值），则会在限制范围上添加一个小的扩展因子，以确保每个轴上的最值和面板的边界不发生重叠。如果为FALSE，则限制范围将直接取自数据或`xlim`/`ylim`的值，最值与面板边界重叠，不发生扩展效果。
-   `clip`：参数确定绘图是否应该被裁剪到绘图面板的范围内。`on`（默认值）表示是，`off`表示否。在大多数情况下，不应更改默认值`on`，因为设置`clip = "off"`可能会导致意外的结果。它允许数据点绘制在绘图的任意位置，包括在绘图边缘。比如说，如果通过`xlim`和`ylim`设置了限制，并且某些数据点超出这些限制，那么这些数据点可能会显示在轴、图例、绘图标题或绘图边缘等位置，进而造成混乱。

#### 坐标轴翻转

大多数统计量和几何形状都假定只对x条件下的y值感兴趣，但假如也对y值条件下的x值感兴趣（或仅仅是想图形翻转90度），可以使用`coord_flip()`调换x和y轴。下图中x轴代表发动机排量（displ），y轴代表城市油耗量（cty）。第一幅图就是刻画以x为条件变量刻画y的曲线，而第三幅图虽然x轴仍然是displ，却是以y（cty）为条件变量刻画的曲线。

```{r}
library(tidyverse)
library(patchwork)
p1 <- ggplot(mpg, aes(displ, cty)) +
  geom_point() +
  geom_smooth() +
  theme_minimal()

p2 <- ggplot(mpg, aes(cty, displ)) +
  geom_point() +
  geom_smooth() +
  theme_minimal()

p3 <- ggplot(mpg, aes(cty, displ)) +
  geom_point() +
  geom_smooth() +
  theme_minimal() +
  coord_flip()

p1 / p2 / p3
```

#### 坐标轴变换

与范围设置一样，我们在标度层面和坐标系层面上都可以进行数据变换。coord_trans有x和y两个参数供坐标轴使用，被称作变换器。标度层面的变换发生在统计量计算之前，且不会改变对象的几何形状。但坐标系层面的变换却发生在统计量计算之后，会影响几何形状。若两种变换一起使用，我们可先在变换的尺度上建模，然后在反演到变换前的图形以便于解释，这是常见的分析模式。

```{r}

# coord_trans(
#   x = "identity",
#   y = "identity",
#   xlim = NULL,
#   ylim = NULL,
#   limx = deprecated(),
#   limy = deprecated(),
#   clip = "on",
#   expand = TRUE
# )

```

```{r}
library(tidyverse)
library(scales)
library(patchwork)
p1 <- ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  coord_trans(x = "identity", y = "identity") +
  theme_minimal()

p2 <- ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  coord_trans(x = log_trans(10), y = log_trans(10)) +
  # 转换成对数坐标轴
  theme_minimal() 

p1 / p2
```

`coord_trans(x = "identity", y = "identity")`使得坐标系保持标准的线性比例。

`coord_trans(x = log_trans(10), y = log_trans(10))`通过 coord_trans()函数直接应用对数变换到整个坐标系上。总的来说，p1对数据做了标度的转换，然后通过位置标度仍映射到线性坐标轴上，而 p2则完全按照对数比例来展示数据点和轴刻度。

```{r}
library(tidyverse)
library(scales)
library(patchwork)
p1 <- ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "lm", se = FALSE) +
  coord_trans(x = exp_trans(10), y = exp_trans(10)) +
  theme_minimal()

p2 <- ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  theme_minimal()

p1 / p2
# 先利用位置标度改变输入定义域，进行对数处理后的平滑统计变换，然后再变换坐标轴，转换散点图为原有的分布形状
```

### 非笛卡尔坐标系

#### 极坐标系

`coord_polar()`函数用于创建极坐标系，最常用于制作饼图、玫瑰图（源自条状图）或雷达图（源自直线几何对象）。但由于角度在小的半径中比在大的半径中更难被感知，因此极坐标的视觉感官性并不佳。极坐标常被用于环形数据，特别是时间和方向数据。

```{r}
# coord_polar(theta = "x", start = 0, direction = 1, clip = "on")
```

-   `theta`：参数决定了哪个变量将被映射为角度（默认是x），哪个变量被映射为半径（默认是y）。
-   `start`：参数是指从12点钟方向开始的偏移量（默认也是从12点钟方向进行偏移的），值以弧度表示。根据direction的值，偏移量可以顺时针或逆时针应用。
-   `direction`：参数决定转换的角度是按顺时针还是逆时针方向表示。1表示顺时针，-1表示逆时针。

## 主题

## 添加额外元素

添加额外的元数据(metadata)、上下文信息和注解等等。该图层往往是最后绘制的图层。

### 添加图形注释

1.  geom_text()：为图形添加文字叙述或者为点添加标签

2.  geom_vline, geom_hline: 为图形添加辅助线

参数详解： - `xintercept` 或 `yintercept`：用于指定参考线的位置

-   `color`：用于指定参考线的颜色。

-   `linetype`：用于指定参考线的线型，可以是
    "solid"（实线）、"dashed"（虚线）、"dotted"（点线）、"dotdash"（点划线）或者其他
    ggplot2 中预定义的线型。

-   `linewidth`：用于指定参考线的粗细程度。

-   `alpha`：用于指定参考线的透明度。

3.  geom_abline：向图形添加任意斜率和截距的直线

-   最主要的参数就是`intercept`和`slope`。`color`,
    `linetype`和`linewidth`等参数不再详细展开。
-   参数`slope`表示斜率。`intercept`表示截距，若指定为0，且`slope`未进行声明，则默认斜率为1

5.  geom_rect:

-   需要指定矩形的四个角的坐标，通过 `xmin`、`xma`x`、`ymin`和`ymax\`
    参数来指定。
-   还可以使用 `fill` 参数来填充矩形的颜色，使用 `alpha`
    参数来指定矩形的透明度，使用 `color`参数来指定矩形的边框颜色。

6.  arrow()添加箭头

geom_line, geom_path,
geom_segment都可以使用arrow参数在线上放置箭头,用arrow()函数绘制箭头，它有如下参数：

-   length: 箭头的长度，需要`unit(长度， 单位)`的格式。

-   ends: 箭头的位置，可取值为 "last"（默认，箭头在线段终点处）或
    "first"（箭头在线段起点处）。

-   type: 箭头的类型，可取值为 "open"（默认，空心箭头）或"closed"（实心箭头）。

-   angle: 箭头的夹角，以度数为单位，默认为 30 度。

*箭头的颜色和线的颜色保持一致*

``` r
geom_line(color = 'red', arrow = arrow(length = unit(0.1,'inches'),type = 'closed', ends = 'first'))
```

## 图例

### 定义

图例和坐标轴存在着天然的可比性。图例标题(legend title)和坐标轴标题(axis
label)是等价的。图例标示(legend key)和刻度标签(tick
label)皆由标度的断点(break)决定。要绘制图例，图形必须收集每一种图形属性(如颜色，大小，形状)的使用信息，一般就是收集颜色属性。该信息为何种数据以及为何种几何对象决定了图例的绘制。标度的断点用来确定图例标示的值。

以收集颜色属性的数据信息为例，如果该数据为离散型的，那么断点就是所有离散数据的值。使用的对应的一系列几何对象则被用来确定如何绘制这些标示。

![](笔记图片素材\生成图例类型.png)

如果该数据为连续型的，此时仍然按照断点来确定图例的值，只不过结果会是一个渐变的色条。断点可以自行设置。

### 图例的调整------利用theme主题

1.  图例的位置和对齐

使用`theme(legend.position = )`设置。其值可为`right`, `left`, `top`,`bottom`,
`none (不加图例)`。或者是一个表示位置的数值。这个数值型位置由`legend.justification`给定的相对边角位置表示（取0，1之间的值），它是一个长度为2的数值型向量：右上角为c(1，1), 左下角为c(0, 0)。可以自行调整，如：

``` r
theme(legend.position = c(0.9, 0.9))
```

2.  图例标题

``` r
# 标题的命名，寻找映射的图形属性，一般是颜色属性，所以这样设置即可改变图例标题
labs(color = "")
labs(size = "")

# 设置图例标题大小，一般设置为和坐标轴标题一样的大小
theme(legend.title = element_text(size = 16))

# 设置图例标题位置居中，一般不设置
theme(legend.title.align = 0.5)
```

3.  图例标签

``` r
# 设置标签大小，可自行调整细节
theme(legend.text = element_text(size = 12))

# 调整图例标签的位置，设置为0.5即为居中
theme(legend.text.align = 0.5)
```

4.  图例背景

``` r
# 设置图例背景为白底黑边，一般不设置
theme(legend.background = element_rect(fill = "white", color = "black"))
```

5.  图例标示

``` r
# 设置图例标示的背景为白底
theme(legend.key = element_rect(fill = "white"))

# 设置图例标示的高度和宽度，可以变相改变整个图例区域的大小，等号后面为 unit（x，单位）的形式
theme(legend.key.height = unit(1.5, "mm"))
theme(legend.key.width = unit(1.2, "cm"))
```

#### 关于geom_text()的详解

几个参数：

1.  mapping：用于映射数据中的变量到文本标签中的不同图形属性，例如位置、颜色、大小等。(x,
    y数据的映射可以采用默认在或者重新声明)

2.  label：用于指定文本标签的文本内容。

3.  hjust, vjust：用于控制文本标签相对于其位置的水平和垂直对齐方式。

4.  size：用于指定文本标签的大小。

5.  color：用于指定文本标签的颜色。

6.  angle：用于指定文本标签的旋转角度。

7.  fontface：用于指定文本标签的字体类型（例如粗体、斜体等）。

``` r
geom_text(aes(x = , y = , label = ), size = , color = , fontface = )
# fontface 指的是字体样式，如"plain"、"italic"、"bold" 和 "bold.italic"
```

==此外，标签之间可能会出现重合==。此时可以使用`ggrepel`包的`geom_text_repel()`函数来解决问题

该函数有很多参数，可以自行查阅，但基础的部分和geom_text()是类似的。里面的max.overlaps参数用于控制标签之间的最大重叠数，如果同一位置有超过这个最大值的标签发生了重叠，那么多余的标签将被省略。可以尝试增加
max.overlaps
参数的值，以允许更多的标签重叠。但是要注意，如果重叠的标签过多，可能会导致标签之间的可读性降低，因此应该在可读性和美观性之间做出权衡。

## 保存

对于ggplot2对象，可以用`ggsave()`函数保存，同时该函数有多个参数对保存设置进行调整。使用`?ggplot2::ggsave()`阅读使用文档。常用的参数：`filename`指定保存图片的名称地址；`plot`指定ggplot2对象，默认为`plot=last_plot()`；`dpi`指定保存的分辨率，特别是当使用了`showtext`包后，为保持字体大小不会缩放，指定`dpi=90`。

```{r}
library(tidyverse)
library(showtext)

showtext_auto()
font_path <- "fonts/ChillDuanSans_Medium.otf"
font_add("hanchan", font_path)

mpg %>% 
  ggplot(aes(x = displ, y = cty)) +
  geom_point(size = 3, color = "#FA8072") +
  geom_smooth(method = lm, se = FALSE, color = "#D8BFD8", lwd = 1.5) +
  theme_minimal() +
  theme(
    text = element_text(family = "hanchan")
  ) 

# ggsave(filename = "plot/notes/output_img/ggsave_demo.png", plot = last_plot(), dpi = 90)
```

# 实战

## 类别比较型图表

### 柱形图系列

在柱形图中，**类别型或序数型变量**映射到横轴的位置，数值型变量映射到矩形的高度。柱形图控制柱形的两个重要参数是："设置系列数据格式"中的"系列重叠"和"分类间距"。"分类间距"控制同一数据系列的柱形宽度，数值范围为\[0.0，1.0\]；"系列重叠"控制**不同数据系列**之间的距离，数值范围为\[-1.0,
1.0\]。

### 克利夫兰点图

克利夫兰点图大致有三种不同的类型（棒棒糖图、克利夫兰点图、哑铃图），但三者基本类似，故归纳成同一类别。棒棒糖图（lollipop chart）传达了与柱形图或者条形图相同的信息，只是将矩形转变成线条，这样可减少展示空间，重点放在数据点上，从而看起来更加简洁、美观。克利夫兰点图（Cleveland's dot plot）：也就是我们常用的滑珠散点图，非常类似棒棒糖图，只是没有连接的线条，重点强调数据的排序展示及互相之间的差距。哑铃图（dumbbell plot）：可以看成多数据系列的克利夫兰点图，只是使用直线连接了两个数据系列的数据点。哑铃图主要用于：1、展示在同一时间段两个数据点的相对位置（增加或者减少）；2、比较两个类别之间的数据值差别。

```{r}
library(tidyverse)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

data <- read.csv("plot/notes/data/DotPlots_Data.csv")
data <- data %>% pivot_longer(cols = where(is.numeric), names_to = "Sex", values_to = "Value")

ggplot(data, aes(x = Value, y = City)) +
  geom_line(aes(group = City)) +
  geom_point(aes(fill = Sex), color = "black", shape = 21, size = 3) +
  labs(title = "Dumbbell plot") +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25),
    axis.title = element_text(hjust = 1, size = 12),
    axis.text = element_text(size = 10)
  )

# ggsave(filename = "plot/notes/output_img/dumbbell_plot.png", plot = last_plot(), dpi = 90)
```

![](output_img/dumbbell_plot.png)

### 南丁格尔玫瑰图

南丁格尔玫瑰图即极坐标下的柱形图，是一种圆形的柱状图，使用**圆弧的半径长短**表示数据的大小（数量的多少）。每个数据类别或间隔在径向图上**划分为相等分段**，每个分段从中心延伸多远（与其所代表的数值成正比）取决于极坐标轴线。因此，从极坐标中心延伸出来的**每一环**可以当作**标尺**使用，用来表示分段大小并代表较高的数值。

南丁格尔玫瑰图会将数据的比例大小放大，所以适合对比大小相等的数值。此外，该图在数据量较多时更能节省绘图空间。如果特殊一点，x轴变量为环状周期型序数（如月份，星期）等，南丁格尔玫瑰图的效果会更好。

单数据系列或多数据系列的南丁格尔玫瑰图都可以绘制：

## 数值关系型图表

### 散点图系列

#### 趋势显示的二维散点图

散点图可以提供几个关键信息：

-   变量之间是否存在数量关联趋势（线性还是非线性。
-   观察是否存在离群值，从而分析这些离群值对建模分析的影响。

同时可以在散点图中添加回归曲线或平滑曲线。

##### 残差分析图

```{r}
library(tidyverse)
library(broom)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

fit <- lm(cty ~ displ, data = mpg) %>% augment()
df <- fit %>% 
  mutate(.abs.resid = abs(.resid))

ggplot(df, aes(x = displ)) +
  geom_line(aes(y = .fitted), color = "lightgrey", lwd = 1.5) +
  geom_segment(aes(xend = displ, y = .fitted, yend = cty), alpha = .2) +
  geom_point(aes(y = .fitted), shape = 1) +
  geom_point(
    mapping = aes(
      y = cty,
      size = .abs.resid,
      fill = .abs.resid
    ),
    shape = 21,
    color = "black"
  ) +
  labs(title = "Residual Analysis Plot") +
  scale_fill_gradient(
    name = "Residual",
    low = "black",
    high = "red"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25),
    axis.title = element_text(hjust = 1, size = 15),
    axis.text = element_text(size = 12)
  ) +
  guides(
    size = "none"
  )
# ggsave(filename = "plot/notes/output_img/residual_plot.png", plot = last_plot(), dpi = 90)
```

![](output_img/residual_plot.png)

#### 分布显示的二维散点图

#### 分布显示的二维散点图

##### 气泡图

气泡图是一种多变量图表，是散点图的变体，但是不同于散点图的是，每个气泡的面积代表第三个维度的数据。气泡图通过气泡的位置及面积大小，可分析数据之间的相关性。

同时为了避免数据的重叠遮挡，一般设置气泡的透明度。

```{r}
library(tidyverse)
library(showtext)
showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

filter(gapminder::gapminder, year == "2007") %>%
  ggplot(aes(x = gdpPercap, y = lifeExp)) +
  geom_point(
        mapping = aes(size = pop, fill = continent, color = continent), stroke = 1.5, 
        shape = 21,
        color = "black",
        alpha = .3
  ) +
  labs(
        x = "Gdp per Capita", 
        y = "Life Expectancy", 
        title = "Bubble Plot"
  ) +
  scale_fill_viridis_d(option = "magma", begin = 0.1, end = 0.8) +
  scale_color_viridis_d(option = "magma", begin = 0.1, end = 0.8) +
  scale_size(range = c(1, 35), name = "Population (M)") +
  theme_minimal() +
  theme( 
        text = element_text(family = "siyuan"),
        plot.title = element_text(size = 25),
        axis.title = element_text(size = 15, hjust = 1),
        axis.text = element_text(size = 12)
  ) +
  guides(
        size = "none",
        fill = guide_legend(override.aes = list(size = 8))
  )

# ggsave(filename = "plot/notes/output_img/bubble_plot.png", plot = last_plot(), dpi = 90)
```

![](output_img/bubble_plot.png)

### 散点曲线图系列

### 相关系数图系列

#### （带标签的）热力图

我们不仅要关注相关系数的绝对值大小，同时更加看重它们的正负号。因此，相关矩阵的颜色图和一般矩阵的颜色图应该有所区别：即应当选取两种色差较大的颜色序列来展示不同符号的相关系数。例如红色、蓝色分别表示正、负相关系数。

```{r}
library(tidyverse)
library(RColorBrewer)
library(showtext)
showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

cor_mat <- round(cor(mtcars, method = "pearson"), 2)
df <- reshape2::melt(cor_mat)
col_pal <- brewer.pal(7, "Set1")

ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "black") +
  geom_text(size = 4, aes(label = value), color = "white") +
  labs(title = "Correlation Coefficient Heatmap") +
  scale_fill_gradient2(low = col_pal[2], high = col_pal[1], mid = "#f7f7f7", na.value = NA) +
  coord_equal() +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"), 
    axis.title = element_blank(),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 25),
  )

# ggsave(filename = "plot/notes/output_img/heatmap_plot.png", plot = last_plot(), dpi = 90)
```

![](output_img/heatmap_plot.png)

#### 气泡图

气泡图是将一个网格矩阵映射到气泡的面积大小和颜色序列上，同时在上半部分使用气泡图显示相关系数，下半部分使用相关系数数值展示结果，这样可以更加清晰地观察数据。

```{r}
library(tidyverse)
library(RColorBrewer)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

cor_mat <- round(cor(mtcars, method = "pearson"), 2)
df <- reshape2::melt(cor_mat)
col_pal <- brewer.pal(7, "Set1")

df %>% 
  mutate(abs_value = abs(value)) %>% 
  ggplot(aes(x = Var1 , y = Var2)) +
    geom_point(aes(size = abs_value, fill = value), shape = 21, colour = "black") +
    labs(title = "Correlation Coefficient Heatmap") +
    scale_fill_gradient2(low = col_pal[2], mid = "white", high = col_pal[1], na.value = NA) +
    scale_size_area(max_size = 13, guide = "none") +
    theme_minimal() +
    theme(
      text = element_text(family = "siyuan"),
      plot.title = element_text(size = 25),
      axis.title = element_blank(),
      axis.text = element_text(size = 12),
      legend.position="right"
    )

# ggsave(filename = "plot/notes/output_img/heatmap_bubble_plot.png", plot = last_plot(), dpi = 90)
```

![](output_img/heatmap_bubble_plot.png)

## 数据分布型图表

### 金字塔图和镜面图

金字塔图和镜面图通常显示两个组别分布的差异，它们共用一个x轴。

```{r}
library(tidyverse)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

data <- read_csv("plot/notes/data/Population_Pyramid_Data.csv", col_select = -1)
new_data <- mutate(data, age = fct(age)) %>% 
  mutate(pop = if_else(gender == "female", -pop, pop))

ggplot(new_data) +
  geom_col(aes(x = age, y = pop, fill = gender), color = "black", linewidth = 0.25) +
  geom_hline(yintercept = 0, linewidth = 1) +
  labs(title = "Diverging bar chart") +
  scale_y_continuous(limits = c(-400, 400)) +
  scale_fill_viridis_d(option = "magma", begin = .2, end = .6, alpha = .8) +
  coord_flip() +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 20, family = "siyuan"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    legend.direction = "horizontal",
    legend.position = c(1, 1),
    legend.justification = c(1, 1)
  )

# ggsave(filename = "plot/notes/output_img/diverging_bar_chart.png", plot = last_plot(), dpi = 90)
```

![](output_img/diverging_bar_chart.png)

### 柱形分布图系列

带误差线的柱形图就是使用**每个类别的均值**作为柱形的高度，再根据每个类别的**标准差**绘制误差线，但这种图无法显示数据的分布情况。所以在带误差线的柱形图的基础上添加抖动散点图（jitter chart）可以方便观察数据的分布规律。前面提过，抖动散点图就是每个类别数据点的Y轴数值保持不变，然后数据点X轴数值沿着X轴类别标签中心线在一定范围内随机生成，绘制成散点图。这在一定程度上表示出了局部分布，比如可以看出哪个Y值的对应散点数更多。

```{r}
library(tidyverse)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)
data <- read.csv("plot/notes/data/bar_distribution.csv")

ggplot(data, aes(x = Class, y = Value)) +
  stat_summary(fun = mean, fun.args = list(mult = 1), geom = "bar", width = .6, color = "black", fill = "white", lwd = 1) +
  geom_jitter(aes(fill = Class), position = position_jitter(0.2), shape = 21, size = 3) +
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", width = .2, lwd = 1) +
  labs(title = "Bar Distribution With Jitter Dots") +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25), 
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, hjust = 1),
    legend.position = "none",
  )
# ggsave(filename = "plot/notes/output_img/bar_distribution.png", plot = last_plot(), dpi = 90)
```

![](output_img/bar_distribution.png)

## 时间序列型图表

### 折线图与面积图系列

折线图用于在连续间隔或时间跨度上显示定量数值，最常用来显示趋势和关系。

在折线图（line chart）中，X轴包括类别型或者序数型变量，分别对应文本坐标轴和序数坐标轴（如日期坐标轴）两种类型；Y轴则为数值型变量。在散点图系列中，曲线图（带直线而没有数据标记的散点图）与折线图的图像显示效果类似。但在曲线图中，**X轴必须为数值格式**，这是两者之间最大的区别。所以，如果X轴变量为数值格式，则应该使用曲线图来显示数据，而不是折线图。

面积图（area graph）又叫区域图，是在折线图的基础之上形成的，它将折线图中的折线与自变量坐标轴之间的区域使用颜色或者纹理填充（填充区域称为"面积"），这样可以更好地突出趋势信息，同时让图表更加美观。但是这种图标一般只适用于数据系列的面积图。多数据系列的面积图由于存在互相遮挡的情况，所以会导致数据表达过于冗余，反而影响数据的清晰表达。

#### 两条折线间的面积图

两条折线之间可以使用面积填充，这样可以很清晰地观察数据之间的差异变化，这种图表只适用于双数据系列的数值差异比较展示。填充颜色可以只选择单色，或者是双色分段填充（当变量一大于变量二时，是一种颜色，反之则是另一种颜色。

```{r}
library(tidyverse)
library(ggridges)
library(RColorBrewer)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

df <- read_csv(file = "plot/notes/data/Line_Data.csv")
data <- mutate(df, date = as.Date(date)) %>% 
  mutate(
    min_val = map2_dbl(AMZN, AAPL, min),
    max_val = map2_dbl(AMZN, AAPL, max)
  )

ggplot(data, aes(x = date)) +
  geom_ridgeline_gradient(
    aes(y = min_val, height = max_val - min_val, fill = max_val - min_val)
  ) +
  geom_line(aes(y = AMZN), color = "black", lwd = 0.75) +
  geom_line(aes(y = AAPL), color = "black", lwd = 0.75) +
  labs(title = "Fill Area Between Lines") +
  scale_x_date(date_breaks = "1 year") +
  scale_fill_gradientn(colours = brewer.pal(9, "YlGnBu"), name = "Value") +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 20), 
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    legend.direction = "horizontal",
    legend.position = c(1, 0.1),
    legend.justification = c(1, 1),   
    legend.background = element_blank(),
  )

# ggsave(filename = "plot/notes/output_img/line_area_chart.png", plot = last_plot(), dpi = 90)
```

![](output_img/line_area_chart.png)

#### 堆积面积图

堆积面积图（stacked area
graph）的原理与多数据系列面积图相同，但它能同时显示多个数据系列，**每一个系列的开始点是先前数据系列的结束点**。堆积面积图上的最大面积代表了所有数据量的总和，是一个整体。**各个堆积起来的面积表示各个数据量的大小**，这些堆积起来的面积图在表现**大数据的总量分量的变化情况**时格外有用，所以层叠面积图不适用于表示带有负值的数据集。总的来说，堆积面积图侧重于表现不同时间段（数据区间）的多个分类累加值之间的趋势。

```{r}
library(tidyverse)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

data <- read_csv("plot/notes/data/StackedArea_Data.csv") 
data <- data %>% mutate(Date = as.Date(Date)) %>% 
  pivot_longer(
    cols = -Date,
    names_to = "Countries",
    values_to = "Values"
  )

ggplot(data, aes(x = Date, y = Values)) +
  geom_area(aes(fill = Countries), alpha = 1, position = "stack", color = "black") +
  labs(title = "Stacked Plot") +
  scale_fill_viridis_d() +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25),
    axis.title = element_text(hjust = 1, size = 13),
    axis.text = element_text(size = 10)
  ) 

# ggsave(filename = "plot/notes/output_img/stacked_plot.png", plot = last_plot(), dpi = 90)
```

![](output_img/stacked_plot.png)

在堆积面积图的基础之上，将各个面积的因变量的数据加和后的总量进行归一化就形成了百分比堆积面积图。该图并不能反映总量的变化，但是可以清晰地反映每个数值所占百分比随时间或类别变化的趋势线，对于分析各个指标**分量**占比极为有用。所以前者关注更总体的总量趋势变化，后者更关注个体的占比变化。

```{r}
library(tidyverse)
library(showtext)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

data <- read_csv("plot/notes/data/StackedArea_Data.csv") 
data <- data %>% mutate(Date = as.Date(Date)) %>% 
  pivot_longer(
    cols = -Date,
    names_to = "Countries",
    values_to = "Values"
  )

ggplot(data, aes(x = Date, y = Values)) +
  geom_area(aes(fill = Countries), alpha = 1, position = "fill", color = "black") +
  labs(title = "Stacked Plot") +
  scale_fill_viridis_d() +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25),
    axis.title = element_text(hjust = 1, size = 13),
    axis.text = element_text(size = 10)
  ) 

# ggsave(filename = "plot/notes/output_img/stacked_fill_plot.png", plot = last_plot(), dpi = 90)
```

![](output_img/stacked_fill_plot.png)

#### 时间序列螺旋图

```{r}
library(tidyverse)
library(readxl)
library(showtext)
library(RColorBrewer)

showtext_auto()
font_path <- "plot/notes/fonts/SiYuanCN-Heavy.otf"
font_add("siyuan", font_path)

N <- 24
fillcolor <- brewer.pal(n = 9, name = "Spectral")
data <- read_xlsx("plot/notes/data/SpiralChart_Data.xlsx")

data <- mutate(data, Date = as.Date(Date), Day = day(Date), Time = hm(Time), Value = as.numeric(Value)) %>% 
  mutate(Hour = hour(Time) + minute(Time) / 60) %>% 
  mutate(
    hour_group = cut(
      Hour, 
      breaks = seq(0, 24, 0.5), 
      include.lowest = TRUE, 
      right = FALSE,
      label = seq(0, 23.5, 0.5)
      )
    ) %>% 
  mutate(hour_group = as.numeric(as.character(hour_group))) %>% 
  mutate(day_order = Day - min(Day)) %>% 
  mutate(Value2 = Value / max(Value))
         
bars_demo <- group_by(data, day_order, hour_group) %>%
  summarize(MeanTT = mean(Value2)) %>% 
  mutate(
    Value = MeanTT * max(data$Value),
    xmin = hour_group,
    xmax = lead(xmin, n = 1L, default = max(xmin) + 0.5),
    ymin = day_order * N + hour_group,
    ymax = day_order * N + hour_group + MeanTT * N * 1.1
  )

poly_demo <- bars_demo %>% 
  rowwise() %>% 
  reframe(
    hour = hour_group, 
    Value = Value, 
    x = c(xmin, xmax, xmax, xmin),
    y = c(ymin, ymin + 0.5, ymax + 0.5, ymax)
  )

ggplot(poly_demo, aes(x = x, y = y, group = interaction(day_order, hour), fill = Value)) +
  geom_polygon(color = "black") +
  labs(
    title = "Spiral Chart",
    y = "Date"
  ) +  
  scale_x_continuous(
    limits = c(0, 24), 
    breaks = seq(0, 23, 1), 
    minor_breaks = 0 : 24,
    labels = paste0(rep(c(0, 1:11), each = 1), rep(c("AM","PM"), each = 12))
  ) +
  scale_y_continuous(
    limits = c(-12, max(poly_demo$y)), 
    breaks = seq(N, max(poly_demo$y), N),
    labels = unique(data$Date) 
  ) +
  scale_fill_gradientn(colours = fillcolor)+
  coord_polar() +
  theme_minimal() +
  theme(
    text = element_text(family = "siyuan"),
    plot.title = element_text(size = 25),
    axis.title = element_blank(),
    axis.text = element_text(size = 10)
  )

ggsave("plot/notes/output_img/spiral_chart.png", plot = last_plot(), dpi = 90)
```

![](output_img/spiral_chart.png)

## 局部整体型图表

### 圆环图


## 高维数据可视化

## 地理空间型图表
